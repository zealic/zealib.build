<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup>
    <ZealibBuildPath Condition="'$(ZealibBuildPath)' == ''">$(MSBuildExtensionsPath)\Zealib.Build</ZealibBuildPath>
  </PropertyGroup>
  
  <UsingTask
      TaskName="ProcessFile"
      TaskFactory="CodeTaskFactory"
      AssemblyFile="$(MSBuildToolsPath)\Microsoft.Build.Tasks.v4.0.dll" >
    <ParameterGroup>
      <InputFile ParameterType="System.String" Required="True" />
      <OutputFile ParameterType="System.String" Required="True" />
      <IsEncode ParameterType="System.Boolean" Required="True" />
      <Pipelines ParameterType="Microsoft.Build.Framework.ITaskItem[]" Required="True" />
    </ParameterGroup>
    <Task>
      <Using Namespace="System" />
      <Using Namespace="System.Collections.Generic" />
      <Using Namespace="System.IO" />
      <Using Namespace="System.IO.Compression" />
      <Using Namespace="System.Reflection" />
      <Using Namespace="System.Security.Cryptography" />
      <Using Namespace="System.Text" />
      <Using Namespace="Microsoft.Build.Framework" />
      <Code Type="Method" Language="cs">
      <![CDATA[
public override bool Execute() {
    var list = new List<Func<Stream, bool, Stream>>();
    foreach (var pipeline in Pipelines) {
      var currentPipeline = pipeline;
      switch(pipeline.ItemSpec.ToUpper()) {
        case "BASE64":
          list.Add((Stream stream, bool encode) => CreateBase64Stream(currentPipeline, stream, encode));
          break;
        case "GZIP":
          list.Add((Stream stream, bool encode) => CreateGZipStream(currentPipeline, stream, encode));
          break;
        case "XOR":
          list.Add((Stream stream, bool encode) => CreateXorStream(currentPipeline, stream, encode));
          break;
        default:
          Log.LogError("Not supported pipeline \"{0}\".", currentPipeline.ItemSpec);
          break;
      }
    }
    list.Reverse();
    
    using(var inStream = File.OpenRead(InputFile))
    using(var outStream = File.Create(OutputFile)) {
      Stream readStream = inStream;
      Stream writeStream = outStream;
      
      var allWriteStream = new Stack<Stream>();
      if(IsEncode) {
        foreach(var createStream in list) {
          writeStream = createStream(writeStream, true);
          if(writeStream == null) return false;
          allWriteStream.Push(writeStream);
        }
      }
      else {
        foreach(var createStream in list) {
          readStream = createStream(readStream, false);
          if(readStream == null) return false;
        }
      }
      
      int reads = 0;
      byte[] buffer = new byte[4096];
      while((reads = readStream.Read(buffer, 0, 4096)) > 0)
        writeStream.Write(buffer, 0, reads);
      
      Stream flushStream;
      while(allWriteStream.Count > 0) {
        var stream = allWriteStream.Pop();
        stream.Flush();
        stream.Close();
      }
      readStream.Close();
    }
    
    return true;
}

private Stream CreateBase64Stream(
    Microsoft.Build.Framework.ITaskItem item,
    Stream stream, bool encode) {
  string lineSizeStr = item.GetMetadata("LineSize");
  int lineSize = 76;
  if(!string.IsNullOrEmpty(lineSizeStr)) {
    int actualLineSize;
    if(!int.TryParse(lineSizeStr, out actualLineSize)) {
      Log.LogError("Invalid metadata value Base64.LineSize.");
      return null;
    }
    
    if(actualLineSize > 10)
      lineSize = actualLineSize;
  }
  return new Base64Stream(stream, encode ? Base64Stream.Mode.Encode : Base64Stream.Mode.Decode) {
    OutputLineLength = lineSize
  };
}

private Stream CreateGZipStream(
    Microsoft.Build.Framework.ITaskItem item,
    Stream stream,
    bool encode) {
  return new GZipStream(stream, encode ? CompressionMode.Compress : CompressionMode.Decompress, true);
}

private Stream CreateXorStream(
    Microsoft.Build.Framework.ITaskItem item,
    Stream stream,
    bool encode) {
  string factorsStr = item.GetMetadata("Factors");
  if(string.IsNullOrEmpty(factorsStr)) {
    Log.LogError("Metadata value Xor.Factors is required.");
    return null;
  }
  byte[] factors = ParseBytes(factorsStr);
  if(factors.Length < 1) {
    Log.LogError("Metadata value Xor.Factors size must greater than 1.");
    return null;
  }
  
  return new XorStream(stream, factors);
}

private static byte[] ParseBytes(string value) {
  var list = new System.Collections.Generic.List<byte>();
  foreach(string item in value.Split(',')) {
    var factor = item;
    if(factor.StartsWith("0x", StringComparison.OrdinalIgnoreCase)) {
      factor = factor.Substring(2);
      list.Add(byte.Parse(factor, System.Globalization.NumberStyles.HexNumber));
    } else {
      list.Add(byte.Parse(factor));
    }
  }
  return list.ToArray();
}

public class XorStream : Stream
{
  private int m_FactorIndex;
  
  public XorStream(Stream baseStream, byte[] factors)
  {
    BaseStream = baseStream;
    Factors = new byte[factors.Length];
    Array.Copy(factors, Factors, factors.Length);
  }

  public byte[] Factors { get; private set; }

  public Stream BaseStream { get; private set; }

  private void ProcessData(byte[] buffer, int offset, int count)
  {
    for (int i = offset; i < offset + count; i++)
    {
      buffer[i] = (byte)(buffer[i] ^ Factors[m_FactorIndex % Factors.Length]);
      m_FactorIndex++;
    }
  }

  public override bool CanRead
  {
    get { return BaseStream.CanRead; }
  }

  public override bool CanSeek
  {
    get { return false; }
  }

  public override bool CanWrite
  {
    get { return BaseStream.CanWrite; }
  }

  public override void Flush()
  {
    BaseStream.Flush();
  }

  public override long Length
  {
    get { return BaseStream.Length; }
  }

  public override long Position
  {
    get { throw new NotSupportedException(); }
    set { throw new NotSupportedException(); }
  }

  public override int Read(byte[] buffer, int offset, int count)
  {
    var reads = BaseStream.Read(buffer, offset, count);
    if(reads > 0) ProcessData(buffer, offset, reads);
    return reads;
  }

  public override long Seek(long offset, SeekOrigin origin)
  {
    throw new NotSupportedException();
  }

  public override void SetLength(long value)
  {
    throw new NotSupportedException();
  }

  public override void Write(byte[] buffer, int offset, int count)
  {
    ProcessData(buffer, offset, count);
    BaseStream.Write(buffer, offset, count);
  }
}

public class Base64Stream : Stream {
  public enum Mode { Encode, Decode }

  private bool _isClosed, _disposed;
  private Mode _mode;
  private int _totalWritten, _totalFlushed, _outputLineLength;
  private Stream _captiveStream;
  private MemoryStream _buffer;
  private CryptoStream _innerStream ;
  private static readonly int _BUFFER_THRESHOLD = 1024;
  
  public Base64Stream(Stream stream, Mode mode) {
    _captiveStream = stream;
    _mode = mode;
  }
  
  public int OutputLineLength {
    get { return _outputLineLength; }
    set { _outputLineLength = value; }
  }
  
  public bool Rfc2045Compliant {
    get { return (_outputLineLength == 76); }
    set { _outputLineLength = (value) ? 76 : 0; }
  }

  protected override void Dispose(bool disposing) {
    try {
      if (!_disposed) {
        if (disposing && (this._innerStream != null)) {
          _innerStream.Flush();
          _innerStream.Close(); // final transform
          _isClosed = true;
          HandleBufferedOutput(true);
        }
        _disposed = true;
      }
    }
    finally {
      base.Dispose(disposing);
    }
  }

  public override void Flush() {
    if (_disposed) throw new ObjectDisposedException("Base64Stream");
    _innerStream.Flush();
    HandleBufferedOutput(true);
  }

  private void HandleBufferedOutput(bool flush)
  {
    if(!CanWrite) return;
    // are we buffering?
    if (_outputLineLength > 0) {
      // is the buffer is full? or are we closed?
      if (_isClosed || (_buffer.Length > _BUFFER_THRESHOLD) || (flush && _buffer.Length > 0)) {
        byte[] b = _buffer.ToArray();
        int i;
        for (i = 0; i+_outputLineLength <= b.Length; i+=_outputLineLength) {
          _captiveStream.Write(b, i, _outputLineLength);
          _captiveStream.WriteByte(13); //13==CR
          _captiveStream.WriteByte(10); //10==LF
          _totalFlushed += _outputLineLength;
        }

        if (!_isClosed)
          _buffer.SetLength(0);

        if (flush) {
          _captiveStream.Write(b, i, b.Length-i);
          _totalFlushed += b.Length-i;
        }
        else
          _buffer.Write(b, i, b.Length-i);
      }
    }
  }

  public override int Read(byte[] buffer, int offset, int count) {
    if (_disposed) throw new ObjectDisposedException("Base64Stream");

    if (_innerStream == null) {
      ICryptoTransform transform = (_mode == Mode.Decode)
        ? (ICryptoTransform) new FromBase64Transform()
        : (ICryptoTransform) new ToBase64Transform();

      _innerStream = new CryptoStream(_captiveStream, transform, CryptoStreamMode.Read);
    }

    return _innerStream.Read(buffer, offset, count);
  }

  public override void Write(byte[] buffer, int offset, int count) {
    if (_disposed) throw new ObjectDisposedException("Base64Stream");

    if (_innerStream == null) {
      ICryptoTransform transform = (_mode == Mode.Decode)
        ? (ICryptoTransform) new FromBase64Transform()
        : (ICryptoTransform) new ToBase64Transform();

      Stream s = null;
      if (_outputLineLength > 0) {
        _buffer= new MemoryStream();
        s= _buffer;
      }
      else s = _captiveStream;

      _innerStream = new CryptoStream(s, transform, CryptoStreamMode.Write);
    }

    if (count==0) return;

    _innerStream.Write(buffer, offset, count);
    _totalWritten += count;

    HandleBufferedOutput(false);
  }

  public override bool CanRead { get { return (_mode == Mode.Decode); } }

  public override bool CanWrite { get {return (_mode == Mode.Encode);} }

  public override bool CanSeek { get { return false; } }

  public override long Seek(long offset, SeekOrigin origin) {
    throw new NotSupportedException();
  }

  public override void SetLength(long value) {
    throw new NotSupportedException();
  }

  public override long Length { get { throw new NotSupportedException(); } }

  public override long Position {
    get { return _totalWritten; }
    set { throw new NotSupportedException(); }
  }
}
      ]]>
      </Code>
    </Task>
  </UsingTask>
  
  <UsingTask
      TaskName="CleanSolutionFile"
      TaskFactory="CodeTaskFactory"
      AssemblyFile="$(MSBuildToolsPath)\Microsoft.Build.Tasks.v4.0.dll" >
    <ParameterGroup>
      <Files ParameterType="System.String[]" Required="True" />
      <ProjectNamePatterns ParameterType="System.String[]" />
      <ItemPatterns ParameterType="System.String[]" />
    </ParameterGroup>
    <Task>
      <Using Namespace="System" />
      <Using Namespace="System.Collections.Generic" />
      <Using Namespace="System.Reflection" />
      <Using Namespace="System.Text" />
      <Using Namespace="System.Text.RegularExpressions" />
      <Code Type="Method" Language="cs">
      <![CDATA[
private class SolutionInfo {
  public class ProjectInfo {
    private const string REGEX_PATTERN = 
      "^Project\\(" +
      "\"(?<ProjectType>[^\"]+)\"" + @"\)" + @"\s*=\s*" +
      "\"(?<ProjectName>[^\"]+)\"" + @"\s*,\s*" +
      "\"(?<ProjectPath>[^\"]+)\"" + @"\s*,\s*" +
      "\"(?<ProjectGuid>[^\"]+)\"\\s*$";
    private readonly static Regex s_Regex = new Regex(REGEX_PATTERN);
    
    public ProjectInfo(string info) {
      var match = s_Regex.Match(info);
      
      if(!match.Success) {
        Console.WriteLine(info);
        throw new ArgumentException("Invalid project info.", "info");
      }
      ProjectType = match.Result("${ProjectType}");
      ProjectName = match.Result("${ProjectName}");
      ProjectPath = match.Result("${ProjectPath}");
      ProjectGuid = match.Result("${ProjectGuid}");
    }
    
    public string ProjectType { get; private set; }
    public string ProjectName { get; private set; }
    public string ProjectPath { get; private set; }
    public string ProjectGuid { get; private set; }
    public List<string> SolutionItems { get; set; }
    
    public override string ToString() {
      var sb = new StringBuilder();
      sb.AppendFormat("Project(\"{0}\") = \"{1}\", \"{2}\", \"{3}\"\r\n",
        ProjectType, ProjectName, ProjectPath, ProjectGuid);
      if(SolutionItems != null && SolutionItems.Count > 0) {
        sb.AppendLine("\tProjectSection(SolutionItems) = preProject");
        foreach(var item in SolutionItems) {
          sb.AppendLine("\t\t" + item);
        }
        sb.AppendLine("\tEndProjectSection");
      }
      sb.Append("EndProject");
      return sb.ToString();
    }
    
  }

  private List<object> m_Items = new List<object>();
  
  public SolutionInfo(string file) {
    var lines = File.ReadAllLines(file);
    
    ProjectInfo info = null;
    List<string> solutionItems = null;
    foreach(var line in lines) {
      if(line.Trim().StartsWith("Project(")) {
        info = new ProjectInfo(line);
      } else if(line.Trim() == "EndProject") {
        m_Items.Add(info);
        info = null;
      } else if(info != null) {
        if(line.Trim().StartsWith("ProjectSection(")) {
          solutionItems = new List<string>();
        }
        else if(line.Trim() == "EndProjectSection") {
          info.SolutionItems = solutionItems;
          solutionItems= null;
        }
        else if(solutionItems != null)
          solutionItems.Add(line.Trim());
      }
      else if(info == null) {
        m_Items.Add(line);
      }
    }
  }
  
  public void RemoveProjects(Func<ProjectInfo, bool> condition) {
    var removeList = new List<object>();
    foreach(var item in m_Items) {
      var info = item as ProjectInfo;
      if(info == null) continue;
      if(condition(info)) {
        removeList.Add(info);
        foreach(var str in m_Items) {
          var line = str as string;
          if(line == null) continue;
          if(line.Contains(info.ProjectGuid)) removeList.Add(line);
        }
      }
    }
    
    foreach(var info in removeList) m_Items.Remove(info);
  }
    
  public void RemoveSolutionItems(Func<string, bool> condition) {
    foreach(var item in m_Items) {
      var info = item as ProjectInfo;
      if(info == null || info.SolutionItems == null) continue;
      var removeList = new List<string>();
      foreach(var si in info.SolutionItems) {
        if(condition(si)) removeList.Add(si);
      }
      
      foreach(var si in removeList) info.SolutionItems.Remove(si);
    }
  }
  
  public override string ToString() {
    var sb = new StringBuilder();
    foreach(var o in m_Items) {
      sb.AppendLine(o.ToString());
    }
    return sb.ToString();
  }
} // class SloutionInfo

private void RemoveProjectFromSolution(string slnFile) {
  var sln = new SolutionInfo(slnFile);
  foreach(var pattern in ProjectNamePatterns)
    sln.RemoveProjects(p => new Regex(pattern).IsMatch(p.ProjectName));
  foreach(var pattern in ItemPatterns)
    sln.RemoveSolutionItems(m => new Regex(pattern).IsMatch(m));
  File.WriteAllText(slnFile, sln.ToString(), new UTF8Encoding(true, true));
}

public override bool Execute() {
    if(ProjectNamePatterns == null) ProjectNamePatterns = new string[0];
    if(ItemPatterns == null) ItemPatterns = new string[0];
    
    foreach (var file in Files) RemoveProjectFromSolution(file);
    return true;
}
]]>
      </Code>
    </Task>
  </UsingTask>
</Project>