<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup>
    <ZealibBuildPath Condition="'$(ZealibBuildPath)' == ''">$(MSBuildExtensionsPath)\Zealib.Build</ZealibBuildPath>
    <ZealibBuild-CodePath>$(ZealibBuildPath)\Common\Code\</ZealibBuild-CodePath>
    <ZealibBuild-Code-ProcessFile>$([System.IO.File]::ReadAllText($(ZealibBuild-CodePath)\ProcessFile.cs))</ZealibBuild-Code-ProcessFile>
    <ZealibBuild-Code-ProcessFile>$([MSBuild]::Unescape($(ZealibBuild-Code-ProcessFile)))</ZealibBuild-Code-ProcessFile>
    <ZealibBuild-Code-XorStream>$([System.IO.File]::ReadAllText($(ZealibBuild-CodePath)\XorStream.cs))</ZealibBuild-Code-XorStream>
    <ZealibBuild-Code-XorStream>$([MSBuild]::Unescape($(ZealibBuild-Code-XorStream)))</ZealibBuild-Code-XorStream>
    <ZealibBuild-Code-Base64Stream>$([System.IO.File]::ReadAllText($(ZealibBuild-CodePath)\Base64Stream.cs))</ZealibBuild-Code-Base64Stream>
    <ZealibBuild-Code-Base64Stream>$([MSBuild]::Unescape($(ZealibBuild-Code-Base64Stream)))</ZealibBuild-Code-Base64Stream>
    <ZealibBuild-TaskCode-ProcessFile>
<![CDATA[
$(ZealibBuild-Code-ProcessFile)
$(ZealibBuild-Code-XorStream)
$(ZealibBuild-Code-Base64Stream)
]]>
    </ZealibBuild-TaskCode-ProcessFile>
  </PropertyGroup>
  
  <UsingTask
      TaskName="ProcessFile"
      TaskFactory="CodeTaskFactory"
      AssemblyFile="$(MSBuildToolsPath)\Microsoft.Build.Tasks.v4.0.dll" >
    <ParameterGroup>
      <InputFile ParameterType="System.String" Required="True" />
      <OutputFile ParameterType="System.String" Required="True" />
      <IsEncode ParameterType="System.Boolean" Required="True" />
      <Pipelines ParameterType="Microsoft.Build.Framework.ITaskItem[]" Required="True" />
    </ParameterGroup>
    <Task>
      <Code Type="Class" Language="cs"><![CDATA[$(ZealibBuild-TaskCode-ProcessFile)]]></Code>
    </Task>
  </UsingTask>
  
  <UsingTask
      TaskName="CleanSolutionFile"
      TaskFactory="CodeTaskFactory"
      AssemblyFile="$(MSBuildToolsPath)\Microsoft.Build.Tasks.v4.0.dll" >
    <ParameterGroup>
      <Files ParameterType="System.String[]" Required="True" />
      <ProjectNamePatterns ParameterType="System.String[]" />
      <ItemPatterns ParameterType="System.String[]" />
    </ParameterGroup>
    <Task>
      <Using Namespace="System" />
      <Using Namespace="System.Collections.Generic" />
      <Using Namespace="System.Reflection" />
      <Using Namespace="System.Text" />
      <Using Namespace="System.Text.RegularExpressions" />
      <Code Type="Method" Language="cs">
      <![CDATA[
private class SolutionInfo {
  public class ProjectInfo {
    private const string REGEX_PATTERN = 
      "^Project\\(" +
      "\"(?<ProjectType>[^\"]+)\"" + @"\)" + @"\s*=\s*" +
      "\"(?<ProjectName>[^\"]+)\"" + @"\s*,\s*" +
      "\"(?<ProjectPath>[^\"]+)\"" + @"\s*,\s*" +
      "\"(?<ProjectGuid>[^\"]+)\"\\s*$";
    private readonly static Regex s_Regex = new Regex(REGEX_PATTERN);
    
    public ProjectInfo(string info) {
      var match = s_Regex.Match(info);
      
      if(!match.Success) {
        Console.WriteLine(info);
        throw new ArgumentException("Invalid project info.", "info");
      }
      ProjectType = match.Result("${ProjectType}");
      ProjectName = match.Result("${ProjectName}");
      ProjectPath = match.Result("${ProjectPath}");
      ProjectGuid = match.Result("${ProjectGuid}");
    }
    
    public string ProjectType { get; private set; }
    public string ProjectName { get; private set; }
    public string ProjectPath { get; private set; }
    public string ProjectGuid { get; private set; }
    public List<string> SolutionItems { get; set; }
    
    public override string ToString() {
      var sb = new StringBuilder();
      sb.AppendFormat("Project(\"{0}\") = \"{1}\", \"{2}\", \"{3}\"\r\n",
        ProjectType, ProjectName, ProjectPath, ProjectGuid);
      if(SolutionItems != null && SolutionItems.Count > 0) {
        sb.AppendLine("\tProjectSection(SolutionItems) = preProject");
        foreach(var item in SolutionItems) {
          sb.AppendLine("\t\t" + item);
        }
        sb.AppendLine("\tEndProjectSection");
      }
      sb.Append("EndProject");
      return sb.ToString();
    }
    
  }

  private List<object> m_Items = new List<object>();
  
  public SolutionInfo(string file) {
    var lines = File.ReadAllLines(file);
    
    ProjectInfo info = null;
    List<string> solutionItems = null;
    foreach(var line in lines) {
      if(line.Trim().StartsWith("Project(")) {
        info = new ProjectInfo(line);
      } else if(line.Trim() == "EndProject") {
        m_Items.Add(info);
        info = null;
      } else if(info != null) {
        if(line.Trim().StartsWith("ProjectSection(")) {
          solutionItems = new List<string>();
        }
        else if(line.Trim() == "EndProjectSection") {
          info.SolutionItems = solutionItems;
          solutionItems= null;
        }
        else if(solutionItems != null)
          solutionItems.Add(line.Trim());
      }
      else if(info == null) {
        m_Items.Add(line);
      }
    }
  }
  
  public void RemoveProjects(Func<ProjectInfo, bool> condition) {
    var removeList = new List<object>();
    foreach(var item in m_Items) {
      var info = item as ProjectInfo;
      if(info == null) continue;
      if(condition(info)) {
        removeList.Add(info);
        foreach(var str in m_Items) {
          var line = str as string;
          if(line == null) continue;
          if(line.Contains(info.ProjectGuid)) removeList.Add(line);
        }
      }
    }
    
    foreach(var info in removeList) m_Items.Remove(info);
  }
    
  public void RemoveSolutionItems(Func<string, bool> condition) {
    foreach(var item in m_Items) {
      var info = item as ProjectInfo;
      if(info == null || info.SolutionItems == null) continue;
      var removeList = new List<string>();
      foreach(var si in info.SolutionItems) {
        if(condition(si)) removeList.Add(si);
      }
      
      foreach(var si in removeList) info.SolutionItems.Remove(si);
    }
  }
  
  public override string ToString() {
    var sb = new StringBuilder();
    foreach(var o in m_Items) {
      sb.AppendLine(o.ToString());
    }
    return sb.ToString();
  }
} // class SloutionInfo

private void RemoveProjectFromSolution(string slnFile) {
  var sln = new SolutionInfo(slnFile);
  foreach(var pattern in ProjectNamePatterns)
    sln.RemoveProjects(p => new Regex(pattern).IsMatch(p.ProjectName));
  foreach(var pattern in ItemPatterns)
    sln.RemoveSolutionItems(m => new Regex(pattern).IsMatch(m));
  File.WriteAllText(slnFile, sln.ToString(), new UTF8Encoding(true, true));
}

public override bool Execute() {
    if(ProjectNamePatterns == null) ProjectNamePatterns = new string[0];
    if(ItemPatterns == null) ItemPatterns = new string[0];
    
    foreach (var file in Files) RemoveProjectFromSolution(file);
    return true;
}
]]>
      </Code>
    </Task>
  </UsingTask>
</Project>